{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\r\nTitle 1\r\n\r\n\r\n\r\n",
      "last_modified": "2021-06-27T17:15:47-04:00"
    },
    {
      "path": "index.html",
      "title": "locCSN",
      "description": "Construction local cell specific networks from single cell data\n",
      "author": [
        {
          "name": "Xuran Wang",
          "url": "https://xuranw.github.io/personalwebsite/"
        }
      ],
      "contents": "\r\nlocCSN is a package that calculates gene networks for each cell from single-cell datasets. \r\nHow to cite locCSN\r\nThis work has not published yet, please see bioRxiv.\r\nInstallation\r\npip install locCSN\r\nSource code are stored in Python Folder.\r\nMore Information\r\nPlease see Tutorial.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-06-27T17:17:58-04:00"
    },
    {
      "path": "vignettes.html",
      "title": "Local Cell-Specific Network (locCSN)",
      "description": "Tutorial of construction local cell specific networks from single cell data\n",
      "author": [
        {
          "name": "Xuran Wang",
          "url": "https://xuranw.github.io/personalwebsite/"
        }
      ],
      "contents": "\r\n\r\nContents\r\nHow to cite locCSN\r\nGet StartedDataset Summary\r\n\r\nSimple Example of locCSN using Chutype DatasetLoad Datasets\r\nCalculate Pearson’s Correlation\r\nCalculate CSN test statistics\r\n\r\nComparing networks between two groups of cellsData Summary\r\nCSN Construction of L4 cell-group\r\nComparison of ASD and Control groups\r\n\r\nTrajectory analysis using Brain Cortex Atlas Dataset\r\nReferences\r\n\r\nlocCSN is a package that calculates gene networks for each cell from single-cell datasets. \r\nHow to cite locCSN\r\nThis work has not published yet, please see bioRxiv.\r\nGet Started\r\nFirst install locCSN pacakge. All locCSN python functions are also stored in Python Folder.\r\npip install locCSN\r\nPlease download datasets stored in DataStore. Large datasets can be accessed by this link.\r\nDataset Summary\r\nDataset\r\nChutype\r\nASD Brain\r\nBrain Cortex Atlas\r\nReference\r\nChu et al.(2016)\r\nVelmeshev et al.(2019)\r\nPolioudakis et al.(2019)\r\n# of cell\r\n1018\r\n104,559\r\n35,543\r\ngenes for analysis\r\n51\r\n942\r\n444\r\nData Availability\r\nGSE75748\r\nPRJNA434002\r\nwebsite\r\nSimple Example of locCSN using Chutype Dataset\r\nIn this example, we reproduce the results of Chutype dataset in paper.\r\nLoad Datasets\r\nThere are 51 marker genes and 1018 cells from 7 cell types. The gene expression are stored in logChumaker.txt and corresponding cell types in chutypectname.txt. Cell types are H1, H9, DEC, EC, HFF, NPC and TF. In our paper, we focus on cell type DEC and NPC.\r\n# Import packages\r\nimport locCSN\r\nimport os\r\nimport scanpy as sc\r\nimport pandas as pd\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\n# Set path to data\r\nos.chdir('yourpathtodata/Chutype/')\r\n\r\n# read in Chutype dataset\r\ndata = sc.read_text('logChumarker.txt')\r\ndata.shape\r\ndata = data.transpose() # 1018 cells * 51 genes\r\n\r\ncell_type = pd.read_csv('chutypectname.txt', sep = ' ')\r\ndata.obs = cell_type   # The observation are labeled with cell types.\r\n\r\n# Plot the Heatmap of gene expression\r\nsc.pl.heatmap(data, data.var.index, groupby= \"cell_type\", dendrogram = False, swap_axes = True, \r\n              show_gene_labels= True, cmap='Wistia', figsize=(8,6))\r\nheatmapCalculate Pearson’s Correlation\r\nAfter loading gene expression matrix and cell types, we first show the absolute Pearson’s correlation for DEC and NPC cells.\r\ndata_dec = data[data.obs.cell_type == \"DEC\", ]\r\nX_dec = data_dec.X.transpose()\r\ndata_npc = data[data.obs.cell_type == 'NPC', ]\r\nX_npc = data_npc.X.transpose()\r\n\r\ncorr_dec = np.corrcoef(X_dec)\r\ncorr_npc = np.corrcoef(X_npc)\r\n\r\n\r\nnp.fill_diagonal(corr_dec, 0)\r\nnp.fill_diagonal(corr_npc, 0)\r\n\r\n\r\nplt.subplot(1, 2, 1)\r\nplt.imshow(abs(corr_dec), vmin=0, vmax=0.7, cmap='RdPu')\r\nplt.title('DEC', fontweight =\"bold\")\r\nplt.subplot(1, 2, 2)\r\nplt.imshow(abs(corr_npc), vmin=0, vmax=0.7, cmap='RdPu')\r\nplt.title(\"NPC\", fontweight = \"bold\")\r\nplt.suptitle(\"Absolute Pearson`s Correlation\", fontsize = 14, fontweight = \"bold\")\r\nThe heatmaps for absolute Pearson`s correlations is\r\nabs_corrCalculate CSN test statistics\r\nNow we calculate the CSN test statistics using function csn for cell type DEC and NPC.\r\nimport time\r\nstart = time.time()\r\ncsn_dec = locCSN.csn(X_dec, dev = True)\r\nend = time.time()\r\nprint(end - start) \r\nstart = time.time()\r\ncsn_npc = locCSN.csn(X_npc, dev = True)\r\nend = time.time()\r\nprint(end - start) \r\n#1275 pairs need calculation\r\n#60.3697772026062\r\n#903 pairs need calculation\r\n#35.72847938537598\r\nNow we show what function csn produces. For a specific cell, we compute each pair of genes and store test statistics in an upper diagnol matrix.\r\ntype(csn_dec) \r\n# list\r\nlen(csn_dec) # 138 cells\r\n# Let's see the test statistics for the first cell in DEC\r\nplt.imshow(csn_dec[0].toarray(), vmin = -6, vmax = 6, cmap = 'coolwarm')\r\nplt.title('DEC one cell', fontweight = \"bold\")\r\nplt.colorbar()\r\n#plt.savefig('dec_one_cell.png')\r\none_cellAs we stated in our paper: ‘’Althogh individual CSNs are estimated with considerable noise, average CSNs provide stable estimates of network structure, which provide better estimates of gene block structure.’’ For CSN test statistics matrices within a cell group, we first threshold test statistics and averaged the adjacency matrices with the cell group. The averaged CSN is the estimate of gene co-expression of the cell group. In this example, we thresholded at \\(\\alpha = 0.05\\).\r\nfrom scipy.stats import norm\r\n\r\n# Cutoff at norm(0.95)\r\ncsn_mat = [(item > norm.ppf(0.95)).astype(int) for item in csn_dec]\r\navgcsn_dec = sum(csn_mat).toarray()/len(csn_mat) + np.transpose(sum(csn_mat).toarray()/len(csn_mat))\r\ncsn_mat = [(item > norm.ppf(0.95)).astype(int) for item in csn_npc]\r\navgcsn_npc = sum(csn_mat).toarray()/len(csn_mat) + np.transpose(sum(csn_mat).toarray()/len(csn_mat))\r\n\r\nplt.subplot(1, 2, 1)\r\nplt.imshow(avgcsn_dec, cmap = \"Greens\", vmin = 0, vmax = 0.7)\r\nplt.title('DEC', fontweight =\"bold\")\r\nplt.subplot(1, 2, 2)\r\nplt.imshow(avgcsn_npc, cmap = \"Greens\", vmin = 0, vmax = 0.7)\r\nplt.title('NPC', fontweight = 'bold')\r\nplt.suptitle(\"Averaged CSN, cut at alpha = 0.05\", fontsize=14, fontweight = \"bold\")\r\nThe heatmaps for DEC and NPC are\r\navgcsnComparing networks between two groups of cells\r\nFor comparison between two groups of cells using CSNs, we use the dataset from ASD Brain dataset (Velmeshev et al. 2019). We focus on 942 expressed SFARI ASD genes and compare gene co-expression networks of control and ASD group using Pearson’s correlation and CSN. The comparison methods are sLED and DISTp.\r\nData Summary\r\nThe ASD Brain dataset has 104,559 cells of 16 cell types and is very sparse. We use Metacell(Baran et al. 2019) to reduce the sparsity for the dataset. Please see Metacell website for how to generate metacells. The following analysis is based on metacells, which are stored in this folder.\r\nFor demonstration, we start with metacell expression of 4 Neuron layer cell types: L2/3, L4, L5/6 and L5/6-CC and 942 SFARI genes. The metacell expressions are stored in this folder. Please download them in your own directory.\r\nLet’s take a look at the expression of neuron layers. There are 1778 metacells and 942 genes.\r\n# import scanpy as sc\r\n# load data\r\nos.chdir('yourpathtodata/Velme/')\r\ndata = sc.read_text('Velme_log_mc_cpm_L.txt')\r\ndata = data.transpose() \r\ndata.shape # 1778 metacells * 942 genes\r\nmeta_L = pd.read_csv('Velme_meta_mc_L.txt', sep = ' ') \r\nmeta_L.columns\r\n# Index(['sampleID', 'broad.cluster', 'cluster', 'diagnosis'], dtype='object')\r\ndata.obs = meta_L\r\nsc.pl.heatmap(data, data.var.index, groupby= [\"cluster\", \"diagnosis\"], dendrogram = False, swap_axes = True, cmap='Wistia', figsize=(8,4))\r\nvelme_heatmapThe metadata of metacells can be accessed in data.obs.\r\ndata.obs['cluster'].value_counts()\r\n#L2/3       772\r\n#L4         449\r\n#L5/6-CC    341\r\n#L5/6       216\r\n\r\ndata.obs['diagnosis'].value_counts()\r\n#ASD        936\r\n#Control    842\r\n\r\ngrouped_data = data.obs.groupby(['cluster', 'diagnosis'])\r\ngrouped_data.describe()['sampleID']['count']\r\n#cluster  diagnosis\r\n#L2/3     ASD          414.0\r\n#         Control      358.0\r\n#L4       ASD          238.0\r\n#         Control      211.0\r\n#L5/6     ASD          107.0\r\n#         Control      109.0\r\n#L5/6-CC  ASD          177.0\r\n#         Control      164.0\r\nCSN Construction of L4 cell-group\r\nCSN test statistics are calcaulted within cell group. Now we focus on one cell-group: L4, which contains 449 metacells (238 ASD + 211 Control). Let’s first subset the neuron layers to L4 cell group.\r\nct_name = \"L4\"\r\ndata_L4 = data[data.obs.cluster == ct_name, :]\r\ndata_L4.shape # 449 metacell * 942 genes\r\nmcknn = pd.read_csv('mcknn100_' + ct_name + '.txt', sep = ' ')\r\nmcknn = mcknn.to_numpy()\r\nX_L4 = data_L4.X.transpose()\r\nThe runtime of 942 genes is longer than 1 hour. Therefore we provide a toy example only use a subset of 20 genes and the runtime is approximately 20-40s.\r\nstart = time.time()\r\ncsn_L4_sub = locCSN.csn_loc(X_L4[0:20, :], mcknn)\r\nend = time.time()\r\nprint(end_start)\r\n# 25.824307203292847\r\nFor storage and export to different software platforms, we flatten the CSN test statistics matrices. For each CSN matrix, we vectorize it to a vector, then column-bind the vectors by cells. The final csn flatten matrix is a gene pair * cell matrix. The flattened matrix for \\(G\\) genes and \\(N\\) cells is of size \\(G(G-1)/2 \\times N\\).\r\ncsn_L4_sub_flat = locCSN.csntoflat(csn_L4_sub)  # 20 genes\r\ncsn_L4_sub_flat.shape  #190 gene pairs * 449 cells\r\n# np.savetxt('csn_'+ct_name+'_sub_flat.txt', csn_L4_sub_flat, delimiter = '\\t')\r\nFor analysis and visualization, we threshold the CSN test statistics at \\(\\alpha = 0.01\\) and average CSN within ASD and Control group respectively.\r\ncsn_mat = [(item > norm.ppf(0.99)).astype(int) for item in csn_L4_sub]\r\nmeta_L4 = meta_L[meta_L['cluster'] == ct_name]\r\n\r\nc_index = (meta_L4['diagnosis'].to_numpy() == 'Control').tolist()\r\ncsn_mat_L4_control =  [x for x, y in zip(csn_mat_L4, c_index) if y]\r\na_index = (meta_L4['diagnosis'].to_numpy() == 'ASD').tolist()\r\ncsn_mat_L4_asd =  [x for x, y in zip(csn_mat_L4, a_index) if y]\r\n\r\navgcsn_L4_sub_control = sum(csn_mat_L4_control).toarray()/len(csn_mat_L4_control)\r\navgcsn_L4_sub_control = + np.transpose(avgcsn_L4_sub_control)\r\navgcsn_L4_sub_asd = sum(csn_mat_L4_asd).toarray()/len(csn_mat_L4_asd)\r\navgcsn_L4_sub_asd = + np.transpose(avgcsn_L4_sub_asd)\r\n\r\nmy_dpi = 50\r\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 5), dpi=my_dpi)\r\nprint(fig)\r\nprint(axes)\r\nfig.suptitle(\"Avg CSN for L4, 20 genes, cut at alpha = 0.01\", fontsize = 14, fontweight = \"bold\")\r\naxes[0].set_title('Control', fontweight = \"bold\")\r\naxes[0].imshow(avgcsn_L4_sub_control, cmap = \"Greens\", vmin = 0, vmax = 0.5)\r\naxes[1].set_title('ASD', fontweight = \"bold\")\r\naxes[1].imshow(avgcsn_L4_sub_asd, cmap = \"Greens\", vmin = 0, vmax = 0.5)\r\n#fig.savefig('Velme_Avg_csn_L4_sub.png')\r\nvelme_toy_heatFor visualization in different software platform, we store averaged CSN for ASD and Control group in text file.\r\n# save averaged CSN file control + ASD\r\navgcsn_flat_L4_sub = csntoflat([avgcsn_L4_sub_control, avgcsn_L4_sub_asd])\r\nnp.savetxt('avgcsn_asd_data_'+ct_name+'_sub.txt', avgcsn_flat_L4_sub, delimiter='\\t')\r\nComparison of ASD and Control groups\r\nIn this section, we demonstrate how we compare the gene co-expression using DISTp and sLED. ### DISTp We also inplement the test of DISTp in locCSN package. DISTp requires CSN adjacency matrices that are arranged by cell group.\r\n# Arrange adjacency matrices by cell group\r\ncsn_mat_L4_new = csn_mat_L4_control + csn_mat_L4_asd\r\nn_control = len(csn_mat_L4_control)  # number of the first group\r\n\r\nstart = time.time()\r\npval = locCSN.DISTp(csn_mat_L4_new, n_control)\r\nend = time.time()\r\nprint(end-start)\r\n# 33.536951303482056\r\n\r\npval\r\n# 0.252\r\nThe DISTp pvalue for this toy example is 0.252, which is not significant. The heatmaps of the toy example with 20 genes also show similar gene connection strengths for Control and ASD groups.\r\nThe code for all 942 genes are provided below.  Please do not run when you go through the demo.  It will take a long time to finish.\r\n# code for 942 genes of L4. Do not run!!! It will take too long for demo\r\ncsn_L4 = locCSN.csn_block_loc(X_L4, mcknn)\r\ncsn_L4_flat = locCSN.csntoflat(csn_L4)\r\n\r\n# save the flatten the CSN test statistics for sLED. This is a extremely big file\r\nnp.savetxt('csn_asd_loc_flat_',ct_name, '.txt', csn_L4_flat, delimiter='\\t')\r\n\r\ncsn_mat_L4 = [(item > norm.ppf(0.99)).astype(int) for item in csn_L4]\r\nmeta_L4 = meta_L[meta_L['cluster'] == ct_name]\r\nc_index = (meta_L4['diagnosis'].to_numpy() == 'Control').tolist()\r\ncsn_mat_L4_control =  [x for x, y in zip(csn_mat_L4, c_index) if y]\r\na_index = (meta_L4['diagnosis'].to_numpy() == 'ASD').tolist()\r\ncsn_mat_L4_asd =  [x for x, y in zip(csn_mat_L4, a_index) if y]\r\n\r\n\r\navgcsn_L4_control = sum(csn_mat_L4_control).toarray()/len(csn_mat_L4_control)\r\navgcsn_L4_control = + np.transpose(avgcsn_L4_control)\r\navgcsn_L4_asd = sum(csn_mat_L4_asd).toarray()/len(csn_mat_L4_asd)\r\navgcsn_L4_asd = + np.transpose(avgcsn_L4_asd)\r\n\r\n\r\n# save averaged CSN file control + ASD\r\navgcsn_flat_L4 = csntoflat([avgcsn_L4_control, avgcsn_L4_asd])\r\nnp.savetxt('avgcsn_asd_data_'+ct_name+'.txt', avgcsn_flat_L4, delimiter='\\t')\r\n\r\n\r\ncsn_mat_L4_new = csn_mat_L4_control + csn_mat_L4_asd\r\nn_control = len(csn_mat_L4_control)\r\n\r\npval = locCSN.DISTp(csn_mat_L4_new, n_control)\r\npval\r\n# 0.039\r\nsLED comparison\r\nsLED is a R package for two-sample test for high-dimensional covariance matrices. Details are in this GitHub repo. Let’s get started with installation:\r\n\r\n\r\ninstall.packages(\"devtools\") ## if not installed\r\nlibrary(\"devtools\")\r\ndevtools::install_github(\"lingxuez/sLED\")\r\n\r\n\r\n\r\nApply sLED to correlation matrix of L4 cell group.\r\n\r\n\r\nlibrary(sLED)\r\n# read in gene expression and metadata files\r\nsetwd('yourpathtodata/Velme/')\r\nlog.mc.cpm.L = read.table('Velme_log_mc_cpm_L.txt')\r\nmeta.mc.L = read.table('Velme_meta_mc_L.txt')\r\n\r\n# Let's take L4 as an example\r\nct.name = 'L4'\r\nmeta.mc.diag = as.numeric(meta.mc.L$diagnosis[meta.mc.L$cluster == ct.name] == 'ASD')\r\nlog.mc.L = data.matrix(log.mc.cpm.L[, meta.mc.L$cluster == ct.name])\r\n\r\nlog.mc.L[1:5, 1:5]\r\n#          mc_L_4   mc_L_7  mc_L_10  mc_L_25  mc_L_28\r\n#SAMD11  0.000000 0.000000 0.000000 0.000000 0.000000\r\n#SKI     5.797950 4.036630 5.298243 0.000000 3.842033\r\n#SLC45A1 0.000000 2.814837 0.000000 0.000000 2.269254\r\n#RERE    6.489579 5.775307 5.702040 5.917348 5.959781\r\n#CA6     0.000000 1.965827 0.000000 0.000000 1.894637\r\n\r\n# rownames of expression are ASD genes\r\nasd.genes = rownames(log.mc.L)\r\n\r\nresult.cor = sLED(X = t(log.mc.L[, meta.mc.diag == 0]), Y = t(log.mc.L[, meta.mc.diag == 1]), sumabs.seq = 0.2, npermute = 100, seeds = c(1:100), adj.beta = 0)\r\n# 100 permutation started:\r\n# 10 ,20 ,30 ,40 ,50 ,60 ,70 ,80 ,90 ,100 ,permutations finished.\r\n\r\nresult.cor$pVal\r\n# [1] 0.8\r\n\r\n\r\n\r\nAlthough sLED is designed for covariance matrices, the idea of comparing differences matrix can be applied to co-expression measured by CSN. I have modified sLED code for CSN adjancency matrices.\r\nThe flatten csn test statistics can be found with this link. Please download and extract file csn_asd_loc_flat_L4.txt before excuting codes below.\r\n\r\n\r\n# load functions of sLED for CSNs\r\nsource('https://raw.githubusercontent.com/xuranw/locCSN/main/Rcode/sLEDmodify.R')\r\n\r\ncsn.flat.temp = read.table(paste0('csn_asd_loc_flat_',ct_name, '.txt'))\r\ncsn.flat.temp = data.matrix(csn.flat.temp)\r\ncsn.t.flat = (csn.flat.temp > qnorm(0.99)) + 0 #Threshold at alpha = 0.01\r\nresult.csn = sLED.csn(X = csn.t.flat[, meta.mc.diag == 0], Y = csn.t.flat[, meta.mc.diag == 1], sumabs.seq = 0.2, npermute = 100, seeds = c(1:100))\r\n\r\nresult.csn$pVal\r\n# [1] 0\r\n\r\n\r\n\r\nsLED-CSN produces a significant p-value for comparison of ASD and Control groups for L4 cell group.\r\nleverage genes and DN genes\r\nWe can also identify the leverage genes, which are the non-zero entries of the sparse leading eigenvector. The differential network genes are the ones that explain 90% of the variability among the leverage genes. To get leverage genes and DN genes use the code below.\r\n\r\n\r\n# Leverage genes \r\nlev.L4 = asd.genes[result.csn$leverage > 0]\r\n\r\n# DN genes (top 90%)\r\nnum.dn = min(which(cumsum(sort(result.csn$leverage, decreasing = T)) > 0.9))  # 27\r\ndn.L4.id = which(result.csn$leverage >= sort(result.csn$leverage, decreasing = T)[num.dn])\r\ndn.L4 = asd.genes[dn.L4.id]\r\n\r\n\r\n\r\nWe also plot the heatmap of averaged CSN for DN genes plus 30 random selected genes. DN genes are boxed in the heatmaps.\r\n\r\n\r\nplot.gene.id = c(dn.L4.id, sample(setdiff(1:942, dn.L4, id), 30))\r\n# DN genes + 30 random selected genes\r\n\r\navgcsn.flat = read.table(paste0('avgcsn_asd_data_', ct.name, '.txt'))\r\navg.csn.ctl = flat.to.matrix(avgcsn_temp[, 1])\r\navg.csn.asd = flat.to.matrix(avgcsn_temp[, 2])\r\n\r\nlibrary(reshape2)\r\nm.data.avgcsn.dn = rbind(melt(avg.csn.ctl[plot.gene.id, plot.gene.id]), \r\n                         melt(avg.csn.asd[plot.gene.id, plot.gene.id]))\r\n                         \r\ntemp.dn = dn.L4.id\r\ntemp.non.dn = setdiff(plot.gene.id, dn.L4.id)\r\n# A simple clustering of genes for visualization\r\ndist.dn = dist(cbind(avg.csn.ctl[temp.dn, temp.dn], avg.csn.asd[temp.dn, temp.dn]));\r\ndist.non.dn = dist(cbind(avg.csn.ctl[temp.non.dn, temp.non.dn], avg.csn.asd[temp.non.dn, temp.non.dn]))\r\nhclust.dn = hclust(dist.dn); hclust.non.dn = hclust(dist.non.dn)\r\nmatch.temp.dn = match(temp.dn, plot.gene.id); \r\nmatch.temp.non.dn = match(temp.non.dn, plot.gene.id);\r\norder.temp = c(match.temp.dn[hclust.dn$order], match.temp.non.dn[hclust.non.dn$order])\r\n\r\nn.dn.withnull = length(plot.gene.id); n.dn = length(dn.L4.id)\r\nm.data.avgcsn.dn$X1 = factor(m.data.avgcsn.dn$X1, levels = order.temp)\r\nm.data.avgcsn.dn$X2 = factor(m.data.avgcsn.dn$X2, levels = order.temp)\r\n \r\ncolnames(m.data.avgcsn.dn) = c('gene.x', 'gene.y', 'avgcsn')\r\nm.data.avgcsn.dn$group = factor(rep(c('Control', 'ASD'), each = n.dn.withnull^2), levels = c('Control', 'ASD'))\r\n\r\ndata.rec <- data.frame(y=c(0.5, n.dn+0.5, n.dn+0.5, 0.5), x=c(0.5, 0.5, n.dn+0.5, n.dn+0.5))\r\n\r\np1 = ggplot(m.data.avgcsn.dn, aes(gene.x, gene.y, fill = avgcsn)) + geom_tile(size = 0) + \r\n    geom_polygon(data = data.rec, aes(x=x, y=y), colour=\"black\", fill=NA) + \r\n    facet_wrap(~group) + coord_fixed() +\r\n    scale_fill_distiller(palette = 'Greens', direction = 1) + theme_minimal() + \r\n    theme(axis.text.x = element_blank(), axis.text.y = element_blank(), \r\n          axis.ticks.x = element_blank(), axis.ticks.y = element_blank()) + \r\n    ggtitle(paste0('L4: ', n.dn, ' DN genes')) + \r\n    theme(axis.title = element_blank()) + guides(fill = guide_colorbar(barwidth = 0.5, barheight = 3))\r\n    \r\ndiff.avg.csn.dn = avg.csn.asd[plot.gene.id, plot.gene.id] - avg.csn.ctl[plot.gene.id, plot.gene.id]\r\nm.diff.avg.csn = melt(diff.avg.csn.dn)\r\nm.diff.avg.csn$X1 = factor(m.diff.avg.csn$X1, levels = order.temp)\r\nm.diff.avg.csn$X2 = factor(m.diff.avg.csn$X2, levels = order.temp)\r\ncolnames(m.diff.avg.csn) = c('gene.x', 'gene.y', 'avgcsn')\r\nlim.max = max(0.7, max(abs(m.diff.avg.csn$avgcsn)))\r\n\r\np2 = ggplot(m.diff.avg.csn, aes(gene.x, gene.y, fill = avgcsn)) + geom_tile(size = 0) + \r\n    geom_polygon(data = data.rec, aes(x=x, y=y), colour=\"black\", fill=NA) + coord_fixed() +\r\n    scale_fill_distiller(palette = 'RdBu', direction = -1, limit = c(-lim.max, lim.max)) + theme_minimal() + \r\n    theme(axis.text.x = element_blank(), axis.text.y = element_blank(), \r\n          axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), \r\n          axis.title = element_blank()) + \r\n    ggtitle('Difference') + labs(fill = expression(paste(Delta, 'avgcsn'))) + \r\n    guides(fill = guide_colorbar(barwidth = 0.5, barheight = 3))\r\n\r\nlibrary(cowplot)\r\np_comb = plot_grid(p1, p2, ncol = 2, rel_widths = c(1.6, 1))\r\np_comb\r\n\r\n\r\n\r\nvelme_DN_heatTrajectory analysis using Brain Cortex Atlas Dataset\r\nFor the Brain Cortex Altas Data (Polioudakis et al. 2019), I will only show the downstream analysis after obtaining the averaged CSN for 7 pseudotime points and how we get the Sankey plot for D-curve. The averaged CSN are stored in this folder. PisCES (Liu et al. 2018) is a Matlab package in this gitHub repo\r\nload('avgcsn_Dcurve_list.mat')  %avgcsn_Dcurve_list \r\n% this is a list of averaged CSN for 8 pseudotime points: P, IP, Ex\r\n\r\nT = 8;\r\nN = size(avgcsn_Dcurve_list{1}, 1);\r\nnet_temp = csnto3dmat(avgcsn_Dcurve_list);\r\nZ = PisCES(net_temp, 'T', 0.05*ones(T, 2));\r\nK = max(max(Z));\r\nA_rec = avgcsn_Dcurve_list;\r\nparam.min_flow_size = N/K^2;\r\nparam.frac_min_flow_size = 0.15;\r\n[newZ] = layout_timeline(A_rec, Z', param);\r\nThis section is not necessary. We manually reordered the gene community so that the dense gene community is the first gene community.\r\n% Manually change gene community order\r\nfor i = 1:8\r\n    index = find(newZ(:, i) == 3);\r\n    newZ(newZ(:, i) == 2, i) = 3;\r\n    newZ(newZ(:, i) == 1, i) = 2;\r\n    newZ(index, i) = 1;\r\nend\r\nCreate sankey plot.\r\n[flow_rec, cluster_rec] = create_sankey_tables(newZ, A_rec);\r\nparam.add_class_labels = 1;\r\nparam.draw_whole_timeline = 1;\r\nparam.draw_paired_plots = 0;\r\nparam.which_paired_plots = 1:T-1;\r\nparam.draw_whole_timeline_with_heatmap = 0;\r\nparam.draw_all_plots = 0;\r\n[paired_param] = make_timeline_and_paired_plots(newZ, A_rec, flow_rec,cluster_rec, param);\r\nsankey_plotReferences\r\nDai, Hao, et al. “Cell-specific network constructed by single-cell RNA sequencing data.” Nucleic acids research 47.11 (2019).\r\nChu, Li-Fang, et al. “Single-cell RNA-seq reveals novel regulators of human embryonic stem cell differentiation to definitive endoderm.” Genome biology 17.1 (2016).\r\nVelmeshev, Dmitry, et al. “Single-cell genomics identifies cell type–specific molecular changes in autism.” Science 364.6441 (2019).\r\nBaran, Yael, et al. “MetaCell: analysis of single-cell RNA-seq data using K-nn graph partitions.” Genome biology 20.1 (2019).\r\nPolioudakis, Damon, et al. “A single cell transcriptomic atlas of human neocortical development during mid-gestation.” Neuron 103.5 (2019).\r\nZhu, Lingxue, et al. “Testing high-dimensional covariance matrices, with application to detecting schizophrenia risk genes.” The annals of applied statistics 11.3 (2017).\r\nLiu, Fuchen, et al. “Global spectral clustering in dynamic networks.” Proceedings of the National Academy of Sciences 115.5 (2018).\r\n\r\n\r\n\r\n",
      "last_modified": "2021-06-27T17:18:08-04:00"
    }
  ],
  "collections": []
}
